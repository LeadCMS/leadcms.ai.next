---
id: 102
createdAt: '2025-10-15T09:00:00.000Z'
title: Why We Built LeadCMS with .NET and C#
description: >-
  Discover why we chose .NET and C# as the foundation for LeadCMS and how it delivers enterprise-grade performance and reliability.
excerpt: >-
  .NET isn't just for enterprise applications anymore. Here's why we chose it for LeadCMS and how it powers our modern CMS & CRM platform.
coverImageUrl: ''
coverImageAlt: '.NET Development'
slug: blog/building-with-dotnet
type: blog
author: Peter Liapin
language: en
category: Technology
tags: ['dotnet', 'csharp', 'technology', 'architecture']
allowComments: true
publishedAt: '2025-10-15T09:00:00Z'
featured: false
---

When choosing a technology stack for LeadCMS, we had many options. Node.js, Python, Go, Java - each has its strengths. After careful consideration, we chose **.NET and C#**. Here's why.

## Modern .NET is Different

If your last experience with .NET was years ago, you might be surprised at how much has changed:

### Cross-Platform from Day One

Modern .NET runs on:

- **Linux** - our primary deployment target
- **macOS** - great for development
- **Windows** - still fully supported
- **Containers** - Docker support is first-class

Gone are the days of Windows-only .NET. Today's .NET is truly cross-platform.

### Performance That Competes with Native Code

.NET consistently ranks among the fastest web frameworks in benchmarks:

<Callout type="tip" title="Benchmark Results">
In TechEmpower benchmarks, .NET regularly outperforms Node.js, Python, and Ruby - often by significant margins. For a CMS/CRM handling thousands of requests, this matters.
</Callout>

### Open Source and MIT Licensed

The entire .NET runtime, libraries, and tools are open source with permissive licenses. This aligns perfectly with our open source philosophy for LeadCMS.

## Why C# for a CMS/CRM?

C# brings specific advantages for building a platform like LeadCMS:

### Type Safety

Strong typing catches errors at compile time, not runtime:

```csharp
// This won't compile - caught before deployment
public class Content {
    public string Title { get; set; }
}

// Type mismatch caught immediately
Content content = new Content();
content.Title = 123; // Error: Cannot convert int to string
```

In a CMS/CRM managing critical business data, type safety prevents costly bugs.

### Async/Await Done Right

C# pioneered async/await, making asynchronous code readable:

```csharp
public async Task<Content> GetContentAsync(string slug)
{
    var content = await _database.Contents
        .Where(c => c.Slug == slug)
        .FirstOrDefaultAsync();

    return content;
}
```

Clean, maintainable code for high-performance operations.

### LINQ for Data Queries

Language Integrated Query (LINQ) makes database operations elegant:

```csharp
var featuredPosts = await _database.BlogPosts
    .Where(p => p.Featured && p.Published)
    .OrderByDescending(p => p.PublishedAt)
    .Take(5)
    .ToListAsync();
```

Type-safe queries with IntelliSense support.

### Robust Plugin System

C# assemblies make it easy to build a plugin architecture:

```csharp
public interface ILeadCMSPlugin
{
    string Name { get; }
    void Initialize();
    Task ProcessAsync(Context context);
}
```

Plugins are first-class citizens in .NET, not afterthoughts.

## Enterprise-Grade Tools

.NET provides production-ready tools out of the box:

### Entity Framework Core

Modern ORM with excellent PostgreSQL support:

- **Migrations** for version-controlled schema changes
- **Change tracking** for efficient updates
- **Lazy loading** for optimized queries
- **Raw SQL** when you need it

### Dependency Injection

Built-in DI container for clean architecture:

```csharp
services.AddScoped<IContentService, ContentService>();
services.AddSingleton<ICacheService, RedisCacheService>();
services.AddTransient<IEmailService, EmailService>();
```

No third-party libraries needed.

### Configuration Management

Environment-based configuration that just works:

```csharp
var config = builder.Configuration
    .AddJsonFile("appsettings.json")
    .AddEnvironmentVariables()
    .Build();
```

### Logging and Monitoring

Structured logging built-in:

```csharp
_logger.LogInformation(
    "Content {ContentId} published by {UserId}",
    content.Id,
    userId
);
```

Perfect for production monitoring.

## Developer Experience

Great technology is about more than performance:

### Visual Studio & VS Code

World-class IDE support with:

- **IntelliSense** that actually works
- **Debugging** that's intuitive
- **Refactoring** tools that are reliable
- **Extensions** for any workflow

### NuGet Package Manager

Massive ecosystem of packages:

- Over 300,000 packages available
- Trusted sources with security scanning
- Semantic versioning by convention

### .NET CLI

Powerful command-line tools:

```bash
dotnet new webapi -n MyAPI
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet ef migrations add InitialCreate
dotnet publish -c Release
```

Everything you need for development and deployment.

## Production Ready

.NET powers some of the world's largest applications:

- **Stack Overflow** - one of the busiest websites globally
- **Microsoft** - obvious but worth mentioning
- **Unity** - game engine used by millions
- **Financial services** - banks and trading platforms

If it can handle that scale, it can handle your CMS/CRM needs.

## The LeadCMS Architecture

Here's how we use .NET in LeadCMS:

### Layered Architecture

```
┌─────────────────────┐
│   API Controllers   │  ASP.NET Core
├─────────────────────┤
│  Business Logic     │  Service Layer
├─────────────────────┤
│  Data Access        │  Entity Framework
├─────────────────────┤
│  PostgreSQL         │  Database
└─────────────────────┘
```

Clean separation of concerns for maintainability.

### Plugin System

Plugins are .NET assemblies loaded at runtime:

1. Implement `ILeadCMSPlugin` interface
2. Drop DLL in plugins folder
3. LeadCMS loads and initializes automatically

### RESTful API

ASP.NET Core minimal APIs for clean endpoints:

```csharp
app.MapGet("/api/content/{slug}", async (string slug, IContentService service) =>
{
    var content = await service.GetBySlugAsync(slug);
    return content is not null ? Results.Ok(content) : Results.NotFound();
});
```

## Conclusion

.NET and C# give LeadCMS:

- ✅ **Performance** that scales
- ✅ **Type safety** that prevents bugs
- ✅ **Tools** that boost productivity
- ✅ **Ecosystem** that's mature and stable
- ✅ **Future** that's actively developed

Could we have built LeadCMS with other technologies? Absolutely. But .NET gives us the best foundation for an enterprise-grade, open-source CMS & CRM.

Want to see the code? Check out our [GitHub repository](https://github.com/LeadCMS/leadcms.core) or [get started with LeadCMS](/docs/getting-started/installation) today.
