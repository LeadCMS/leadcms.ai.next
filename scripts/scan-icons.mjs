#!/usr/bin/env node

import fs from 'fs'
import path from 'path'

/**
 * Scans all MDX files for icon usage and generates an icon registry
 * This ensures only used icons are included in the final bundle
 */

// Icons that are used in components but not necessarily in MDX (always include these)
const CORE_ICONS = [
  // Alert and feedback icons
  'AlertCircle',
  'CheckCircle',
  'Info',
  'AlertTriangle',
  'Lightbulb',

  // ContactInfo component icons (mapped from type)
  'Mail',
  'Phone',
  'MapPin',

  // Deploy section hardcoded icons
  'Server',
  'Code',

  // Blog components icons
  'Calendar',
  'Clock',
  'User',
  'ArrowRight',
  'ArrowLeft',

  // Navigation and UI icons that might be referenced
  'Menu',
  'GitBranch',
  'Book',
  'FileText',
  'ChevronDown',
  'ChevronRight',
  'ChevronUp',
  'Globe',
  'Share2',
  'Send',
  'Building',
  'MessageSquare',
  'MessageCircle',
  'X',
  'ArrowUp',
  'Loader2',
  'Check',
  'Circle',
  'MoreHorizontal',
  'List',

  // WhySection and other MDX component icons
  'Package',
  'Settings',
  'ShieldCheck',
  'Lock',
  'Database'
]

/**
 * Extract icon names from MDX content
 * Looks for patterns like: icon="IconName", icon='IconName', or icon: "IconName" (YAML-like)
 */
function extractIconsFromContent(content) {
  // Pattern for HTML-like attributes: icon="IconName"
  const htmlIconMatches = content.match(/icon=["']([^"']+)["']/g) || []
  const htmlIcons = htmlIconMatches.map(match => {
    const iconName = match.match(/icon=["']([^"']+)["']/)[1]
    return iconName
  })

  // Pattern for YAML-like properties: icon: "IconName"
  const yamlIconMatches = content.match(/icon:\s*["']([^"']+)["']/g) || []
  const yamlIcons = yamlIconMatches.map(match => {
    const iconName = match.match(/icon:\s*["']([^"']+)["']/)[1]
    return iconName
  })

  return [...htmlIcons, ...yamlIcons]
}

/**
 * Extract icons from JSX syntax (for backwards compatibility during migration)
 * Looks for patterns like: icon={<IconName className="h-6 w-6" />}
 */
function extractJSXIconsFromContent(content) {
  const jsxIconMatches = content.match(/icon=\{<([A-Za-z]+)[^>]*>\}/g) || []
  return jsxIconMatches.map(match => {
    const iconName = match.match(/icon=\{<([A-Za-z]+)/)[1]
    return iconName
  })
}

function walkDirectory(dir, extensions = ['.mdx']) {
  const files = []

  function walk(currentDir) {
    const items = fs.readdirSync(currentDir, { withFileTypes: true })

    for (const item of items) {
      const fullPath = path.join(currentDir, item.name)

      if (item.isDirectory() && !['node_modules', 'out', '.next'].includes(item.name)) {
        walk(fullPath)
      } else if (item.isFile() && extensions.some(ext => item.name.endsWith(ext))) {
        files.push(fullPath)
      }
    }
  }

  walk(dir)
  return files
}

async function scanIcons() {
  try {
    console.log('üîç Scanning MDX files for icon usage...')

    // Find all MDX files
    const mdxFiles = walkDirectory(process.cwd(), ['.mdx'])

    console.log(`üìÅ Found ${mdxFiles.length} MDX files`)

    const iconSet = new Set(CORE_ICONS)

    // Process each MDX file
    for (const file of mdxFiles) {
      const content = fs.readFileSync(file, 'utf-8')

      // Extract string-based icons (new format)
      const stringIcons = extractIconsFromContent(content)
      stringIcons.forEach(icon => iconSet.add(icon))

      // Extract JSX-based icons (old format, for migration support)
      const jsxIcons = extractJSXIconsFromContent(content)
      jsxIcons.forEach(icon => iconSet.add(icon))

      if (stringIcons.length > 0 || jsxIcons.length > 0) {
        console.log(`üìÑ ${file}: found ${[...stringIcons, ...jsxIcons].join(', ')}`)
      }
    }

    // Filter out invalid icon names (must start with uppercase letter)
    const validIcons = Array.from(iconSet).filter(icon =>
      /^[A-Z][a-zA-Z0-9]*$/.test(icon) && icon !== 'check'
    )
    const iconList = validIcons.sort()
    console.log(`‚ú® Total unique icons found: ${iconList.length}`)
    console.log('Icons:', iconList.join(', '))

    // Generate the icon registry file
    const registryContent = `// Auto-generated icon registry - DO NOT EDIT MANUALLY
// This file is generated by scripts/scan-icons.mjs during build

import {
  ${iconList.join(',\n  ')}
} from 'lucide-react'

export type IconName = ${iconList.map(icon => `'${icon}'`).join(' | ')}

export const ICON_REGISTRY = {
  ${iconList.map(icon => `${icon}: ${icon}`).join(',\n  ')}
} as const

export function getIcon(name: IconName) {
  return ICON_REGISTRY[name]
}
`

    // Ensure lib directory exists
    const libDir = path.join(process.cwd(), 'lib')
    if (!fs.existsSync(libDir)) {
      fs.mkdirSync(libDir, { recursive: true })
    }

    // Write the registry file
    const registryPath = path.join(libDir, 'icon-registry.ts')
    fs.writeFileSync(registryPath, registryContent)

    console.log(`‚úÖ Generated icon registry at: ${registryPath}`)
    console.log(`üì¶ Only ${iconList.length} icons will be bundled`)

  } catch (error) {
    console.error('‚ùå Error scanning icons:', error)
    process.exit(1)
  }
}

// Run if called directly
if (process.argv[1] === new URL(import.meta.url).pathname) {
  scanIcons()
}

export default scanIcons
